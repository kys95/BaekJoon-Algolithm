# 문제
1. nxn크기의 보드에 색이 같거나 다른 사탕이 존재한다.
2. 사탕의 색이 다른 인접한 두 칸을 골라 사탕을 교환한다.
3. 모두 같은 색으로 이루어져 있는 가장 긴 연속부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.
4. 사탕을 먹을 수 있는 최대 개수를 구해라.
5. 단, n은 50이하이다.



# 해결과정
1. 색이 다른 인접한 두 칸을 뒤집고 모두 같은 색으로 이루어진 가장 긴 부분을 찾아야한다.
2. 임의의 두 칸을 뒤집는 경우 50x50=2500, 보드의 같은 색으로 이루어진 부분을 찾을 때 50x50=2500이므로 시간복잡도는 6,250,000이된다.
3. 이에 따라 완전탐색을 이용할 수 있다.
4. 색이 다른 인접한 두 개의 칸을 교환하는 함수 change를 구현한다.
5. change()함수는 이중 for문을 이용하여 행과 열을 비교하는데 오른쪽이나 아래쪽으로 이동하여 비교한다. 그 이유는 왼쪽이나 위쪽은 이미 비교한
   대상이기 때문이다. 색이 다르면 두 칸을 교환하고 가장 긴 부분을 찾는 check()함수를 호출한다.
6. check()함수는 오른쪽으로 행을 비교, 아래쪽으로 열을 비교하여 같은 색이면 카운트해주고 다른 색이면 리셋한다. 이에 따라 같은 색인 횟수가 
   가장 큰 값을 리턴하여 준다.

